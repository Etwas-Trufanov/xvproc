#include <cstring>
#include <fstream>
#include <string>
#include <vector>
#include <stdexcept>
#include "core.hpp"

// Функция для загрузки программы из файла в вектор целых чисел
// filename - имя файла, содержащего программу (последовательность чисел)
// output - вектор, в который будет загружена программа
void load_program(std::string &filename, std::vector<int> &output) {
  int value; // Временная переменная для хранения считанного числа
  std::ifstream f(filename); // Открытие файла для чтения
  while (f >> value) { // Чтение чисел из файла до конца
    output.push_back(value); // Добавление числа в вектор программы
  }
  // Файл автоматически закрывается при выходе из области видимости
}

int main(int argc, char **argv) {
  // Проверка количества аргументов командной строки
  // Ожидаемые аргументы:
  // 1. Имя файла с программой
  // 2. Размер памяти (ОЗУ) для эмулятора
  // 3. (опционально) Флаг -debug для включения отладочного режима
  if (not (argc == 3 or argc == 4)) {
    std::cerr << "Invalid arguments\n";
    std::cout << "Usage: " << argv[0] << " filename ram_size -debug(or not)\n";
    return 1; // Возврат кода ошибки: неверные аргументы
  }

  std::vector<int> program; // Вектор для хранения загруженной программы
  std::size_t size; // Переменная для размера памяти
  std::string filename = argv[1]; // Получение имени файла программы из аргументов

  // Попытка загрузить программу и преобразовать аргумент размера памяти
  try {
    load_program(filename, program); // Загрузка программы из файла
    size = std::stoi(argv[2]); // Преобразование строки в число (размер памяти)
  } catch (std::runtime_error &e) {
    // Обработка ошибок при загрузке файла или преобразовании числа
    std::cerr << e.what();
    return 2; // Возврат кода ошибки: ошибка загрузки программы
  }

  cpu_unit::core cpu0; // Создание экземпляра процессорного ядра (эмулятора)

  try {
    // Инициализация эмулятора:
    // - Загрузка программы в память
    // - Выделение ОЗУ указанного размера
    // - Инициализация регистров
    // - Подключение виртуальных устройств (терминал, файловая система)
    cpu0.init(program, size);

    bool is_debug = false; // Флаг отладочного режима по умолчанию выключен

    // Проверка наличия третьего аргумента (флага отладки)
    if (argc == 4) {
      // Сравнение аргумента со строкой "-debug"
      if (std::strcmp(argv[3], "-debug") == 0) {
        is_debug = true; // Включение отладочного режима
      }
    }

    // Запуск процесса выполнения программы в эмуляторе
    // В отладочном режиме будет выводиться состояние регистров после каждой инструкции
    cpu0.start_process(is_debug);

  } catch (std::runtime_error &e) {
    // Обработка ошибок, которые могут возникнуть во время инициализации или выполнения:
    // - Недостаточный размер памяти (<4)
    // - Программа больше выделенной памяти
    // - Ошибки доступа к памяти во время выполнения
    // - Неверные инструкции
    std::cerr << e.what();
    return 3; // Возврат кода ошибки: ошибка выполнения программы
  }

  // Программа успешно завершила выполнение
  return 0;
}
